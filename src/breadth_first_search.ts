import { alwaysPickMin, PickRequest } from "./picks.ts";
import { PlayoutSource } from "./backtracking.ts";
import { PickTree } from "./pick_tree.ts";
import { PickSet } from "./pick_function.ts";
import { generate, Generated } from "./generated_class.ts";

type RequestFilter = (
  depth: number,
  req: PickRequest,
) => PickRequest | undefined;

type PlayoutFilter = (depth: number) => boolean;

type SearchOpts = {
  /**
   * Replaces each incoming pick request with a new one. The new request might
   * have a narrower range. If the callback returns undefined, the playout will
   * be cancelled.
   */
  replaceRequest: RequestFilter;
  acceptPlayout: PlayoutFilter;
};

/**
 * A filtered search over all possible playouts.
 */
class FilteredSearch {
  readonly tree: PickTree = new PickTree();
  private readonly walk = this.tree.walk();

  private replaceRequest: RequestFilter;
  #acceptPlayout: PlayoutFilter;

  constructor(opts: SearchOpts) {
    this.replaceRequest = opts.replaceRequest;
    this.#acceptPlayout = opts.acceptPlayout;
  }

  getReplies(start?: number, end?: number): number[] {
    return this.walk.getPicks(start, end);
  }

  startPlayout(depth: number): void {
    this.walk.trim(depth);
  }

  doPick(req: PickRequest, depth: number): number | undefined {
    const replaced = this.replaceRequest(depth, req);
    if (replaced === undefined) {
      return undefined;
    }

    const firstChoice = alwaysPickMin.pick(replaced);
    const pick = this.walk.pushUnpruned(firstChoice, replaced);
    return pick;
  }

  acceptPlayout(): boolean {
    return this.#acceptPlayout(this.walk.depth);
  }

  nextPlayout(): number | undefined {
    this.walk.prune();
    return this.walk.pruned ? undefined : this.walk.depth;
  }
}

/**
 * Configures a FilteredSearch to run a breadth-first pass.
 * @param passIdx the number of previous passes that were run.
 * @param more called if more passes are needed.
 */
export function configurePass(
  passIdx: number,
  more: () => void,
): FilteredSearch {
  let moreSent = false;
  function pruned() {
    if (!moreSent) {
      more();
      moreSent = true;
    }
  }
  const replaceRequest = (depth: number, req: PickRequest) => {
    if (depth === passIdx - 1) {
      pruned();
      if (req.min === req.max) {
        return undefined; //  no more playouts
      }
      return new PickRequest(req.min + 1, req.max);
    } else if (depth >= passIdx) {
      pruned();
      return new PickRequest(req.min, req.min);
    }
    return req;
  };

  const acceptPlayout = (depth: number) => {
    if (depth === 0) {
      return passIdx === 0;
    }
    return depth >= passIdx;
  };
  return new FilteredSearch({ replaceRequest, acceptPlayout });
}

export class BreadthFirstSearch extends PlayoutSource {
  search: FilteredSearch;
  private maxDepth = 0;
  private pruned = false;

  constructor() {
    super();
    this.search = configurePass(this.maxDepth, () => {
      this.pruned = true;
    });
  }

  protected startPlayout(depth: number): void {
    // console.log("startPlayout", depth);
    this.search.startPlayout(depth);
  }

  protected doPick(req: PickRequest): number | undefined {
    const result = this.search.doPick(req, this.depth);
    // console.log("doPick", req.toString(), " => ", result);
    return result;
  }

  getReplies(start?: number, end?: number): number[] {
    return this.search.getReplies(start, end);
  }

  protected acceptPlayout(): boolean {
    return this.search.acceptPlayout();
  }

  protected nextPlayout(): number | undefined {
    const depth = this.search.nextPlayout();
    if (depth !== undefined) {
      return depth;
    } else if (!this.pruned) {
      return undefined;
    }

    // Start next pass
    this.pruned = false;
    this.maxDepth++;
    // console.log(`Starting pass ${this.maxDepth}`);
    this.search = configurePass(this.maxDepth, () => {
      this.pruned = true;
    });
    return 0;
  }
}

/**
 * Generates playouts in breadth-first order, using iterative deepening.
 *
 * (The iterable can only be iterated over once.)
 *
 * Note: to avoid duplicate playouts, the return value of
 * {@link PlayoutSource.endPlayout} must be used to filter them.
 */
export function* generatePlayouts(): Iterable<PlayoutSource> {
  const search = new BreadthFirstSearch();
  while (!search.done) {
    yield search;
  }
}

/**
 * Iterates over all values that can be generated by a PickSet.
 *
 * This might be an infinite stream if the PickSet represents an infinite set.
 * The values start with a minimum playout and gradually get larger, as
 * generated by playouts of increasing size.
 */
export function* generateAll<T>(
  set: PickSet<T>,
): IterableIterator<Generated<T>> {
  for (const source of generatePlayouts()) {
    // Keep using the same source until it's finished.
    let gen = generate(set, source);
    while (gen) {
      yield gen;
      gen = generate(set, source);
    }
  }
}

/**
 * Returns the first generated value that satisfies the given predicate, if it's
 * within the given limit.
 *
 * It returns undefined if every possible value was tried.
 */
export function find<T>(
  set: PickSet<T>,
  predicate: (val: T) => boolean,
  opts?: { limit: number },
): Generated<T> | undefined {
  const limit = opts?.limit ?? 1000;

  let count = 0;
  for (const gen of generateAll(set)) {
    if (predicate(gen.val)) {
      return gen;
    }
    if (++count >= limit) {
      throw new Error(
        `findBreadthFirst for '${set.label}': no match found in the first ${limit} values`,
      );
    }
  }
  return undefined;
}

export function takeGenerated<T>(set: PickSet<T>, n: number): Generated<T>[] {
  const result = [];
  for (const gen of generateAll(set)) {
    result.push(gen);
    if (result.length >= n) {
      break;
    }
  }
  return result;
}

/**
 * Returns up to n examples from this Arbitrary, in the same order as
 * {@link generateAll}.
 *
 * There may be duplicates.
 */
export function take<T>(set: PickSet<T>, n: number): T[] {
  return takeGenerated(set, n).map((gen) => gen.val);
}

/**
 * Generates all examples from this Arbitrary, provided that it's not too many.
 *
 * @param opts.limit The maximum size of the array to return.
 *
 * There may be duplicates.
 */
export function takeAll<T>(
  set: PickSet<T>,
  opts?: { limit?: number },
): T[] {
  const limit = opts?.limit ?? 1000;

  const examples = take(set, limit + 1);
  if ((examples.length > limit)) {
    throw new Error(
      `takeAllBreadthFirst for '${set.label}': array would have more than ${limit} elements`,
    );
  }
  return examples;
}
