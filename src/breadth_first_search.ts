import { alwaysPickMin, PickRequest } from "./picks.ts";
import { PlayoutSource } from "./backtracking.ts";
import { PickTree } from "./pick_tree.ts";
import { PickSet } from "./pick_function.ts";
import { generate, Generated } from "./generated_class.ts";

/**
 * Implements a single pass of a breadth-first search.
 */
export class Filter {
  #filtered = false;

  constructor(readonly passIdx: number) {}

  get filtered() {
    return this.#filtered;
  }

  filterRequest(depth: number, req: PickRequest) {
    if (depth < this.passIdx - 1) {
      return req;
    }

    this.#filtered = true;

    if (depth > this.passIdx - 1) {
      return new PickRequest(req.min, req.min);
    } else if (req.min === req.max) {
      return undefined; //  no more playouts
    }
    return new PickRequest(req.min + 1, req.max);
  }
}

/**
 * Generates playouts using an iterative deepening search.
 *
 * Unlike a depth-first search, this will generates shorter playouts before longer ones.
 */
export class BreadthFirstSearch extends PlayoutSource {
  /** Keeps track of which playouts have been pruned, including previous passes. */
  private readonly shared = new PickTree().walk();

  /** Keeps track of playouts that were pruned during the current pass. */
  private pass = new PickTree().walk();

  private filter = new Filter(0);

  constructor(readonly maxPasses?: number) {
    super();
  }

  get currentPass() {
    return this.filter.passIdx;
  }

  protected startPlayout(depth: number): void {
    this.shared.trim(depth);
    this.pass.trim(depth);
  }

  protected doPick(req: PickRequest): number | undefined {
    const replaced = this.filter.filterRequest(this.depth, req);
    if (replaced === undefined) {
      return undefined;
    }

    const firstChoice = alwaysPickMin.pick(replaced);
    const pick = this.pass.pushUnpruned(firstChoice, replaced);
    if (!this.shared.push(req, pick)) {
      return undefined; // pruned in previous pass
    }
    return pick;
  }

  getReplies(start?: number, end?: number): number[] {
    return this.pass.getPicks(start, end);
  }

  protected acceptPlayout(): boolean {
    return !this.shared.pruned;
  }

  protected nextPlayout(): number | undefined {
    this.shared.prune();
    this.pass.prune();
    if (!this.pass.pruned) {
      // continue current pass
      return this.pass.depth;
    }

    const nextPass = this.filter.passIdx + 1;
    if (!this.filter.filtered || nextPass === this.maxPasses) {
      // no more passes needed
      return undefined;
    }

    // Start next pass
    this.pass = new PickTree().walk();
    this.filter = new Filter(nextPass);
    return 0;
  }
}

/**
 * Iterates over all values that can be generated by a PickSet.
 *
 * This might be an infinite stream if the PickSet represents an infinite set.
 * The values start with a minimum playout and gradually get larger, as
 * generated by playouts of increasing size.
 */
export function* generateAll<T>(
  set: PickSet<T>,
): IterableIterator<Generated<T>> {
  const source = new BreadthFirstSearch();
  let gen = generate(set, source);
  while (gen) {
    yield gen;
    gen = generate(set, source);
  }
}

/**
 * Returns the first generated value that satisfies the given predicate, if it's
 * within the given limit.
 *
 * It returns undefined if every possible value was tried.
 */
export function find<T>(
  set: PickSet<T>,
  predicate: (val: T) => boolean,
  opts?: { limit: number },
): Generated<T> | undefined {
  const limit = opts?.limit ?? 1000;

  let count = 0;
  for (const gen of generateAll(set)) {
    if (predicate(gen.val)) {
      return gen;
    }
    if (++count >= limit) {
      throw new Error(
        `findBreadthFirst for '${set.label}': no match found in the first ${limit} values`,
      );
    }
  }
  return undefined;
}

export function takeGenerated<T>(set: PickSet<T>, n: number): Generated<T>[] {
  const result = [];
  for (const gen of generateAll(set)) {
    result.push(gen);
    if (result.length >= n) {
      break;
    }
  }
  return result;
}

/**
 * Returns up to n examples from this Arbitrary, in the same order as
 * {@link generateAll}.
 *
 * There may be duplicates.
 */
export function take<T>(set: PickSet<T>, n: number): T[] {
  return takeGenerated(set, n).map((gen) => gen.val);
}

/**
 * Generates all examples from this Arbitrary, provided that it's not too many.
 *
 * @param opts.limit The maximum size of the array to return.
 *
 * There may be duplicates.
 */
export function takeAll<T>(
  set: PickSet<T>,
  opts?: { limit?: number },
): T[] {
  const limit = opts?.limit ?? 1000;

  const examples = take(set, limit + 1);
  if ((examples.length > limit)) {
    throw new Error(
      `takeAllBreadthFirst for '${set.label}': array would have more than ${limit} elements`,
    );
  }
  return examples;
}
