import {
  alwaysPickDefault,
  IntPicker,
  ParseFailure,
  ParserInput,
  PickRequest,
} from "../picks.ts";

import {
  NOT_FOUND,
  runWithPicks,
  Solution,
  SpanPicker,
  walkAllPaths,
} from "../solver.ts";

import { Success } from "../results.ts";

/** Thrown when a pick fails and backtracking is turned off. */
export class PickFailed extends Error {
  private constructor(msg: string) {
    super(msg);
  }
  static create(req: Arbitrary<unknown>, tries: number): PickFailed {
    return new PickFailed(`Failed to generate ${req} after ${tries} tries`);
  }
}

export type PickOptions<T> = {
  /**
   * Filters out values that don't pass the given filter.
   *
   * @param accept a function that returns true if the picked value
   * should be accepted. If it returns false, pick() will either retry or throw
   * {@link PickFailed}.
   *
   * It should always return true for an arbitrary's default value.
   */
  accept?: (val: T) => boolean;
};

/**
 * A function that can pick values from integer ranges or arbitraries.
 */
export interface PickFunction {
  (req: PickRequest): number;
  <T>(req: Arbitrary<T>, opts?: PickOptions<T>): T;
}

/**
 * A function that generates a member of an Arbitrary, given some picks.
 *
 * The result should be deterministic, depending only on what `pick()`
 * returns.
 *
 * @throws PickFailed when it calls `pick()` and it fails. The callback shouldn't catch
 * this exception, since it's used for backtracking.
 */
export type ArbitraryCallback<T> = (pick: PickFunction) => T;

/**
 * A set of values that can be randomly picked from. Members are generated as
 * needed.
 */
export class Arbitrary<T> {
  readonly callback: ArbitraryCallback<T>;

  /**
   * @param callback reads some picks and either returns a value or RETRY. It
   * should be deterministic and always finish.
   */
  constructor(callback: ArbitraryCallback<T>) {
    this.callback = callback;
    this.default; // dry run
  }

  /**
   * Picks an arbitrary member, based on some picks.
   * @param maxTries how many times to retry filters. Set to 1 to disable backtracking.
   * @throws {@link PickFailed} when it calls `pick()` internally and it fails.
   */
  pick(input: IntPicker, maxTries: number): T {
    if (maxTries < 1 || !Number.isSafeInteger(maxTries)) {
      throw new Error("maxTries must be a positive integer");
    }

    return runWithPicks(input, (spanPicker) => {
      const pick: PickFunction = <T>(
        req: PickRequest | Arbitrary<T>,
        opts?: PickOptions<T>,
      ): number | T => {
        if (req instanceof PickRequest) {
          return input.pick(req);
        }
        const accept = opts?.accept;

        // non-backtracking case
        if (accept === undefined) {
          const level = spanPicker.startSpan();
          const val = req.callback(pick);
          spanPicker.endSpan(level);
          return val;
        }

        // retry when there's a filter
        for (let tries = 0; tries < maxTries; tries++) {
          const level = spanPicker.startSpan();
          const val = req.callback(pick);
          if (accept === undefined || accept(val)) {
            spanPicker.endSpan(level);
            return val;
          }
          if (tries < maxTries - 1) {
            // Cancel only when we're not out of tries.
            spanPicker.cancelSpan(level);
          }
        }

        // Give up. This is normal when backtracking is turned off.
        // Don't cancel so that the picks used in the failed run are available
        // to the caller.
        throw PickFailed.create(req, maxTries);
      };
      return this.callback(pick);
    });
  }

  /**
   * Attempts to pick a value based on a prerecorded list of picks. All filters
   * must succeed the first time, or the parse fails. (There is no
   * backtracking.)
   *
   * This function can be used to test which picks the Arbitrary accepts as
   * input.
   */
  parse(picks: number[]): Success<T> | ParseFailure<T> {
    const input = new ParserInput(picks);
    try {
      const val = this.pick(input, 1);
      return input.finish(val);
    } catch (e) {
      if (e instanceof PickFailed) {
        return { ok: false, guess: this.default, errorOffset: input.offset };
      } else {
        throw e;
      }
    }
  }

  /** The default value of this Arbitrary. */
  get default(): T {
    return this.pick(alwaysPickDefault, 1); // a clone, in case it's mutable
  }

  /**
   * Iterates over all solutions that can be generated by this Arbitrary.
   *
   * Uses a depth-first search, starting from the default value.
   */
  get solutions(): IterableIterator<Solution<T>> {
    const walk = (input: SpanPicker): T | typeof NOT_FOUND => {
      try {
        return this.pick(input, 1);
      } catch (e) {
        if (e instanceof PickFailed) {
          return NOT_FOUND;
        } else {
          throw e;
        }
      }
    };
    return walkAllPaths(walk);
  }

  /**
   * Iterates over all values that can be generated by this Arbitrary.
   *
   * Uses a depth-first search, starting from the default value.
   */
  get members(): IterableIterator<T> {
    function* membersOf(arb: Arbitrary<T>): IterableIterator<T> {
      for (const s of arb.solutions) {
        yield s.val;
      }
    }
    return membersOf(this);
  }

  /**
   * Creates a new arbitrary by mapping each member. (The default value is also
   * mapped.)
   */
  map<U>(convert: (val: T) => U): Arbitrary<U> {
    return new Arbitrary((pick) => {
      const output = pick(this);
      return convert(output);
    });
  }

  /**
   * Creates a new Arbitrary by removing members. (It must not filter out the
   * default value.)
   */
  filter(accept: (val: T) => boolean): Arbitrary<T> {
    if (!accept(this.default)) {
      throw new Error(
        "cannot filter out the default value of an Arbitrary",
      );
    }
    return new Arbitrary((pick) => {
      return pick(this, { accept });
    });
  }

  /**
   * Creates a new Arbitrary by converting each member to another Arbitrary and
   * then picking from it.
   */
  chain<U>(
    convert: (val: T) => Arbitrary<U>,
  ): Arbitrary<U> {
    return new Arbitrary((pick) => {
      const output = pick(this);
      const next = convert(output);
      return pick(next);
    });
  }

  toString() {
    return `Arbitrary(default: ${this.default})`;
  }
}
