import type {
  Arbitrary,
  Pickable,
  PickFunction,
  Row,
  RowPicker,
} from "@/arbitrary.ts";
import type { ArrayOpts } from "../options.ts";

import { assert } from "@std/assert/assert";
import { Domain, Jar } from "@/domain.ts";
import { IntRequest } from "../picks.ts";
import { parseArrayOpts } from "../options.ts";
import { generateAll } from "../ordered.ts";
import { PickTree } from "../pick_tree.ts";
import { arrayLengthBiases } from "../math.ts";
import { Script } from "../script_class.ts";

import * as arb from "./basics.ts";
import { RowJar } from "../jars.ts";

/**
 * Defines an Arbitrary that generates an array by taking distinct values from a
 * Domain.
 *
 * (The comparison is done using the canonical pick sequence for each value.)
 */
export function uniqueArray<T>(
  item: Domain<T>,
  opts?: ArrayOpts,
): Arbitrary<T[]> {
  const { min, max } = parseArrayOpts(opts);

  const startRegionSize = 20;
  const [startBias, extendedBias] = arrayLengthBiases(max - min, {
    startRegionSize,
  });

  const startCoin = arb.biased(startBias);
  const extendedCoin = arb.biased(extendedBias);

  function wantItem(i: number, pick: PickFunction): boolean {
    if ((i - min) < startRegionSize) {
      return pick(startCoin);
    } else {
      return pick(extendedCoin);
    }
  }

  return arb.from(function uniqueArrayCallback(pick) {
    const jar = new Jar(item);
    const out: T[] = [];
    while (out.length < min) {
      if (jar.isEmpty()) {
        throw new Error(
          `not enough unique values; want length.min <= ${out.length}, got: ${min}`,
        );
      }
      out.push(jar.takeAny(pick));
    }
    while (out.length < max) {
      if (jar.isEmpty()) {
        // Add an ending pick to match a regular array.
        pick(new IntRequest(0, 0));
        return out;
      } else if (!wantItem(out.length, pick)) {
        return out;
      }
      out.push(jar.takeAny(pick));
    }
    return out;
  }).with({ name: "uniqueArray" });
}

/** Defines the unique keys in a table. */
export type KeyShape<T> = {
  [K in keyof T]?: Domain<T[K]>;
};

/**
 * Constraints used when generating or validating tables.
 */
export type TableOpts<T extends Record<string, unknown>> = ArrayOpts & {
  keys?: (keyof T & string)[] | KeyShape<T>;
};

export function parseKeyOpts<T extends Row>(
  row: RowPicker<T>,
  opts?: TableOpts<T>,
): KeyShape<T> {
  let keyShape: KeyShape<T> = {};
  if (Array.isArray(opts?.keys)) {
    for (const key of opts?.keys) {
      const first = row.cases[0].shape[key];
      if (!(first instanceof Domain)) {
        if (first === undefined) {
          throw new Error(
            `property '${key}' is declared a unique key, but not defined`,
          );
        }
        throw new Error(
          `property '${key}' is declared a unique key, but not defined as a Domain`,
        );
      }
      keyShape[key] = first;
    }
  } else if (opts?.keys) {
    keyShape = opts.keys;
  }

  for (const columnName in keyShape) {
    for (const c of row.cases) {
      const dom = c.shape[columnName];
      if (!(dom instanceof Domain)) {
        throw new Error(
          `property '${columnName}' is declared a unique key, but not defined as a Domain`,
        );
      }
    }
  }

  return keyShape;
}

function checkKeys<T extends Row>(
  row: RowPicker<T>,
  shape: KeyShape<T>,
  min: number,
): void {
  for (const [columnName, dom] of Object.entries(shape)) {
    assert(dom instanceof Domain);

    const keyCases: Pickable<unknown>[] = row.cases.map((c) =>
      c.shape[columnName]
    );
    const keys = arb.oneOf(...keyCases);

    const count = countDistinct(keys, dom, min);
    if (count < min) {
      const value = count === 1 ? "value" : "values";
      throw new Error(
        `property '${columnName}' has ${count} unique ${value}, but length.min is ${min}`,
      );
    }
  }
}

function countDistinct<T>(
  source: Pickable<T>,
  filter: Domain<T>,
  max: number,
): number {
  if (max === 0) {
    return 0;
  }
  const remaining = new PickTree();
  let count = 0;
  for (const gen of generateAll(source)) {
    const regen = filter.regenerate(gen.val);
    if (regen.ok && remaining.prune(regen)) {
      count++;
      if (count >= max) {
        return max;
      }
    }
  }

  return count;
}

/**
 * Creates an Arbitrary that generates arrays of objects.
 *
 * Each row is generated by choosing from the shapes allowed by a RowPicker.
 *
 * Properties whose names appear in {@link TableOpts.keys} will be constrained
 * to be unique columns. Each possible row shape must define a property for each
 * unique column. The property definitions for a unique column must all be
 * Domains.
 */
export function table<R extends Record<string, unknown>>(
  row: RowPicker<R>,
  opts?: TableOpts<R>,
): Arbitrary<R[]> {
  const { min, max } = parseArrayOpts(opts);
  const keyShape = parseKeyOpts(row, opts);

  checkKeys(row, keyShape, min);

  const startRegionSize = 20;
  const [startBias, extendedBias] = arrayLengthBiases(max - min, {
    startRegionSize,
  });

  const startCoin = arb.biased(startBias);
  const extendedCoin = arb.biased(extendedBias);

  function wantItem(i: number, pick: PickFunction): boolean {
    if ((i - min) < startRegionSize) {
      return pick(startCoin);
    } else {
      return pick(extendedCoin);
    }
  }

  return arb.from((pick) => {
    const jar = new RowJar(row.cases, keyShape);

    const rows: R[] = [];

    const addRow: Script<R | undefined> = Script.make("addRow", (pick) => {
      if (rows.length < min) {
        jar.assertNotEmpty();
      } else {
        if (max !== undefined && rows.length >= max) {
          return undefined;
        }
        if (jar.isEmpty()) {
          return undefined;
        }
        if (!wantItem(rows.length, pick)) {
          return undefined;
        }
      }

      return jar.takeAny(pick);
    });

    for (let row = pick(addRow); row !== undefined; row = pick(addRow)) {
      rows.push(row);
    }
    if (jar.isEmpty()) {
      // Add an ending pick to match a regular array.
      pick(new IntRequest(0, 0));
    }
    return rows;
  }).with({ name: "table" });
}
