import { assertEquals } from "@std/assert";

import { type Failure, failure, type Success, success } from "./results.ts";
import { PlaybackPicker } from "./picks.ts";
import { onePlayout } from "./backtracking.ts";
import { generate } from "./generated.ts";
import type { Generated, PickCallback, PickSet } from "./generated.ts";
import type { Arbitrary } from "./arbitrary_class.ts";

/**
 * A callback for reporting errors while validating a value.
 *
 * The 'at' argument is an optional string or number that identifies where the
 * error occurred, such as an array index or a property name.
 */
export type SendErr = (msg: string, opts?: { at: string | number }) => void;

/**
 * Validates a value, converting it to a pick sequence that can be used to make
 * a copy of it.
 *
 * If the value is valid, returns an array of picks. Otherwise, returns
 * undefined. Validation errors can be reported using sendErr.
 */
export type PickifyCallback = (
  val: unknown,
  sendErr: SendErr,
) => number[] | undefined;

/**
 * A Domain represents a set of JavaScript values that can be both validated and
 * generated.
 *
 * When validating, it takes a value and attempts to convert it into an array of
 * integers (a pick sequence). It contains an Arbitrary that does the opposite
 * operation, converting from picks to values.
 *
 * The mapping between pick sequences and values doesn't have to be one-to-one.
 * The pick sequence that a Domain generates when it parses a value is
 * "canonical" for that value, but the Arbitrary could convert other pick
 * sequences to the same value.
 *
 * Similarly, a Domain might accept more values than the Arbitrary can generate,
 * but only the values generated by the Arbitrary are canonical.
 */
export class Domain<T> implements PickSet<T> {
  #arb: Arbitrary<T>;
  #callback: PickifyCallback;

  /**
   * Constructs a Domain that accepts values generated by an Arbitrary.
   *
   * The callback should accept all values generated by the Arbitrary, and it
   * should generate picks that the Arbitrary can convert back to the original
   * value. (The round trip is implemented by {@link regenerate} and
   * {@link parse}).
   *
   * A property test can be used to verify that the callback is correct.
   */
  constructor(
    arb: Arbitrary<T>,
    callback: PickifyCallback,
  ) {
    this.#arb = arb;
    this.#callback = callback;

    // Verify that we can round-trip the default value.

    const def = arb.default();

    const picks = this.pickify(
      def.val,
      "callback returned undefined",
    );
    if (!picks.ok) {
      throw new Error(
        `can't pickify default of ${arb.label}: ${picks.message}`,
      );
    }
    assertEquals(
      def.replies,
      picks.val,
      `callback's picks don't match for the default value of ${arb.label}`,
    );
  }

  /** The Arbitrary that generates values for this domain. */
  get arb(): Arbitrary<T> {
    return this.#arb;
  }

  /** A label used in error messages about this domain. */
  get label(): string {
    return this.#arb.label;
  }

  /**
   * A bound function that generates values in this domain from picks.
   *
   * (Satisfies the {@link PickSet} interface; not normally used directly.)
   */
  get generateFrom(): PickCallback<T> {
    return this.#arb.generateFrom;
  }

  /**
   * Validates a value, returning a copy created by regenerating it.
   *
   * @throws an Error if the value is not a member of this domain.
   */
  parse(val: unknown): T {
    const gen = this.regenerate(val);
    if (!gen.ok) {
      throw new Error(gen.message);
    }
    return gen.val;
  }

  /**
   * Returns a new domain with only the values accepted by a predicate.
   */
  filter(accept: (val: T) => boolean): Domain<T> {
    return new Domain<T>(this.arb.filter(accept), (val, sendErr) => {
      const gen = this.regenerate(val);
      if (!gen.ok) {
        sendErr(gen.message);
        return undefined;
      }
      if (!accept(gen.val)) {
        sendErr("filter rejected value");
        return undefined;
      }
      return gen.replies;
    });
  }

  /**
   * Validates a value, returning a copy and the picks used to generate it.
   */
  regenerate(val: unknown): Generated<T> | Failure {
    const picks = this.pickify(val);
    if (!picks.ok) {
      return picks;
    }
    return this.generate(picks.val);
  }

  /**
   * Given some picks, attempts to generate the corresponding value.
   */
  generate(picks: number[]): Generated<T> | Failure {
    const picker = new PlaybackPicker(picks);
    const gen = generate(this.#arb, onePlayout(picker));
    if (picker.error) {
      let msg = picker.error;
      if (gen === undefined) {
        msg = `picks not accepted; ${picker.error}`;
      }
      return failure(msg);
    } else if (gen === undefined) {
      return failure(`picks not accepted by ${this.#arb.label}`);
    }
    return gen;
  }

  /**
   * Validates a value, returning an array of picks that could be used to create
   * a copy of it.
   *
   * If the value isn't accepted by this domain, returns a Failure instead.
   *
   * @param defaultMessage an error message to use when the Domain doesn't
   * report a more specific error.
   *
   * (When implementing a Domain, use {@link innerPickify} instead.)
   */
  pickify(
    val: unknown,
    defaultMessage?: string,
  ): Success<number[]> | Failure {
    let firstError: string | undefined = undefined;
    const sendErr: SendErr = (msg, opts) => {
      if (firstError === undefined) {
        const at = opts?.at;
        firstError = at !== undefined ? `${at}: ${msg}` : msg;
      }
    };
    const picks = this.#callback(val, sendErr);
    if (picks === undefined) {
      const err = firstError ?? defaultMessage ?? "not in domain";
      return failure(err);
    }
    return success(picks);
  }

  /**
   * Returns the picks that encode a value, or undefined if the value isn't a
   * member of the domain.
   *
   * If undefined is returned, errors might be reported by calling
   * {@link sendErr}.
   *
   * If a location is supplied, it will be prepended to inner locations.
   *
   * (This function is designed to be convenient to use within a
   * {@link PickifyCallback}.)
   */
  innerPickify(
    val: unknown,
    sendErr: SendErr,
    location?: number | string,
  ): number[] | undefined {
    let innerErr: SendErr = sendErr;
    if (location !== undefined) {
      innerErr = (msg, opts) => {
        const innerAt = opts?.at;
        const at = innerAt ? `${location}.${innerAt}` : "" + location;
        sendErr(msg, { at });
      };
    }
    return this.#callback(val, innerErr);
  }

  /**
   * Converts the domain to a zero-argument function.
   *
   * (Defining a function instead of a constant is useful for forward
   * compatibility, in case you might want to add optional arguments later.)
   */
  asFunction(): () => Domain<T> {
    return () => this;
  }
}
